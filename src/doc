PACKAGE DOCUMENTATION

package dns
    import "github.com/miekg/dns"

    Package dns implements a full featured interface to the Domain Name
    System. Server- and client-side programming is supported. The package
    allows complete control over what is send out to the DNS. The package
    API follows the less-is-more principle, by presenting a small, clean
    interface.

    The package dns supports (asynchronous) querying/replying,
    incoming/outgoing zone transfers, TSIG, EDNS0, dynamic updates, notifies
    and DNSSEC validation/signing. Note that domain names MUST be fully
    qualified, before sending them, unqualified names in a message will
    result in a packing failure.

    Resource records are native types. They are not stored in wire format.
    Basic usage pattern for creating a new resource record:

	r := new(dns.MX)
	r.Hdr = dns.RR_Header{Name: "miek.nl.", Rrtype: dns.TypeMX, Class: dns.ClassINET, Ttl: 3600}
	r.Preference = 10
	r.Mx = "mx.miek.nl."

    Or directly from a string:

	mx, err := dns.NewRR("miek.nl. 3600 IN MX 10 mx.miek.nl.")

    Or when the default TTL (3600) and class (IN) suit you:

	mx, err := dns.NewRR("miek.nl. MX 10 mx.miek.nl.")

    Or even:

	mx, err := dns.NewRR("$ORIGIN nl.\nmiek 1H IN MX 10 mx.miek")

    In the DNS messages are exchanged, these messages contain resource
    records (sets). Use pattern for creating a message:

	m := new(dns.Msg)
	m.SetQuestion("miek.nl.", dns.TypeMX)

    Or when not certain if the domain name is fully qualified:

	m.SetQuestion(dns.Fqdn("miek.nl"), dns.TypeMX)

    The message m is now a message with the question section set to ask the
    MX records for the miek.nl. zone.

    The following is slightly more verbose, but more flexible:

	m1 := new(dns.Msg)
	m1.Id = Id()
	m1.RecursionDesired = true
	m1.Question = make([]Question, 1)
	m1.Question[0] = dns.Question{"miek.nl.", dns.TypeMX, dns.ClassINET}

    After creating a message it can be send. Basic use pattern for
    synchronous querying the DNS at a server configured on 127.0.0.1 and
    port 53:

	c := new(Client)
	in, rtt, err := c.Exchange(m1, "127.0.0.1:53")

    Suppressing multiple outstanding queries (with the same question, type
    and class) is as easy as setting:

	c.SingleInflight = true

    If these "advanced" features are not needed, a simple UDP query can be
    send, with:

	in, err := dns.Exchange(m1, "127.0.0.1:53")

    When this functions returns you will get dns message. A dns message
    consists out of four sections. The question section: in.Question, the
    answer section: in.Answer, the authority section: in.Ns and the
    additional section: in.Extra.

    Each of these sections (except the Question section) contain a []RR.
    Basic use pattern for accessing the rdata of a TXT RR as the first RR in
    the Answer section:

	if t, ok := in.Answer[0].(*dns.TXT); ok {
		// do something with t.Txt
	}


    Domain Name and TXT Character String Representations

    Both domain names and TXT character strings are converted to
    presentation form both when unpacked and when converted to strings.

    For TXT character strings, tabs, carriage returns and line feeds will be
    converted to \t, \r and \n respectively. Back slashes and quotations
    marks will be escaped. Bytes below 32 and above 127 will be converted to
    \DDD form.

    For domain names, in addition to the above rules brackets, periods,
    spaces, semicolons and the at symbol are escaped.


    DNSSEC

    DNSSEC (DNS Security Extension) adds a layer of security to the DNS. It
    uses public key cryptography to sign resource records. The public keys
    are stored in DNSKEY records and the signatures in RRSIG records.

    Requesting DNSSEC information for a zone is done by adding the DO
    (DNSSEC OK) bit to an request.

	m := new(dns.Msg)
	m.SetEdns0(4096, true)

    Signature generation, signature verification and key generation are all
    supported.


    EDNS0

    EDNS0 is an extension mechanism for the DNS defined in RFC 2671 and
    updated by RFC 6891. It defines an new RR type, the OPT RR, which is
    then completely abused. Basic use pattern for creating an (empty) OPT
    RR:

	o := new(dns.OPT)
	o.Hdr.Name = "." // MUST be the root zone, per definition.
	o.Hdr.Rrtype = dns.TypeOPT

    The rdata of an OPT RR consists out of a slice of EDNS0 interfaces.
    Currently only a few have been standardized: EDNS0_NSID (RFC 5001) and
    EDNS0_SUBNET (RFC 6891). Note that these options may be combined in an
    OPT RR. Basic use pattern for a server to check if (and which) options
    are set:

	// o is a dns.OPT
	for _, s := range o.Option {
		switch e := s.(type) {
		case *dns.EDNS0_NSID:
			// do stuff with e.Nsid
		case *dns.EDNS0_SUBNET:
			// access e.Family, e.Address, etc.
		}
	}


    TRANSACTION SIGNATURE

    An TSIG or transaction signature adds a HMAC TSIG record to each message
    sent. The supported algorithms include: HmacMD5, HmacSHA1 and
    HmacSHA256.

    Basic use pattern when querying with a TSIG name "axfr." (note that
    these key names must be fully qualified - as they are domain names) and
    the base64 secret "so6ZGir4GPAqINNh9U5c3A==":

	c := new(dns.Client)
	c.TsigSecret = map[string]string{"axfr.": "so6ZGir4GPAqINNh9U5c3A=="}
	m := new(dns.Msg)
	m.SetQuestion("miek.nl.", dns.TypeMX)
	m.SetTsig("axfr.", dns.HmacMD5, 300, time.Now().Unix())
	...
	// When sending the TSIG RR is calculated and filled in before sending

    When requesting an zone transfer (almost all TSIG usage is when
    requesting zone transfers), with TSIG, this is the basic use pattern. In
    this example we request an AXFR for miek.nl. with TSIG key named "axfr."
    and secret "so6ZGir4GPAqINNh9U5c3A==" and using the server
    176.58.119.54:

	t := new(dns.Transfer)
	m := new(dns.Msg)
	t.TsigSecret = map[string]string{"axfr.": "so6ZGir4GPAqINNh9U5c3A=="}
	m.SetAxfr("miek.nl.")
	m.SetTsig("axfr.", dns.HmacMD5, 300, time.Now().Unix())
	c, err := t.In(m, "176.58.119.54:53")
	for r := range c { /* r.RR */ }

    You can now read the records from the transfer as they come in. Each
    envelope is checked with TSIG. If something is not correct an error is
    returned.

    Basic use pattern validating and replying to a message that has TSIG
    set.

	server := &dns.Server{Addr: ":53", Net: "udp"}
	server.TsigSecret = map[string]string{"axfr.": "so6ZGir4GPAqINNh9U5c3A=="}
	go server.ListenAndServe()
	dns.HandleFunc(".", handleRequest)
	func handleRequest(w dns.ResponseWriter, r *dns.Msg) {
		m := new(Msg)
		m.SetReply(r)
		if r.IsTsig() {
			if w.TsigStatus() == nil {
				// *Msg r has an TSIG record and it was validated
				m.SetTsig("axfr.", dns.HmacMD5, 300, time.Now().Unix())
			} else {
				// *Msg r has an TSIG records and it was not valided
			}
		}
		w.WriteMsg(m)
	}


    DYNAMIC UPDATES

    Dynamic updates reuses the DNS message format, but renames three of the
    sections. Question is Zone, Answer is Prerequisite, Authority is Update,
    only the Additional is not renamed. See RFC 2136 for the gory details.

    You can set a rather complex set of rules for the existence of absence
    of certain resource records or names in a zone to specify if resource
    records should be added or removed. The table from RFC 2136 supplemented
    with the Go DNS function shows which functions exist to specify the
    prerequisites.

    3.2.4 - Table Of Metavalues Used In Prerequisite Section

	CLASS    TYPE     RDATA    Meaning                    Function
	--------------------------------------------------------------
	ANY      ANY      empty    Name is in use             NameUsed
	ANY      rrset    empty    RRset exists (value indep) RRsetUsed
	NONE     ANY      empty    Name is not in use         NameNotUsed
	NONE     rrset    empty    RRset does not exist       RRsetNotUsed
	zone     rrset    rr       RRset exists (value dep)   Used

    The prerequisite section can also be left empty. If you have decided on
    the prerequisites you can tell what RRs should be added or deleted. The
    next table shows the options you have and what functions to call.

    3.4.2.6 - Table Of Metavalues Used In Update Section

	CLASS    TYPE     RDATA    Meaning                     Function
	---------------------------------------------------------------
	ANY      ANY      empty    Delete all RRsets from name RemoveName
	ANY      rrset    empty    Delete an RRset             RemoveRRset
	NONE     rrset    rr       Delete an RR from RRset     Remove
	zone     rrset    rr       Add to an RRset             Insert


CONSTANTS

const (
    DefaultMsgSize = 4096  // Standard default for larger than 512 bytes.
    MinMsgSize     = 512   // Minimal size of a DNS packet.
    MaxMsgSize     = 65536 // Largest possible DNS packet.

)

const (
    RSAMD5           = 1
    DH               = 2
    DSA              = 3
    ECC              = 4
    RSASHA1          = 5
    DSANSEC3SHA1     = 6
    RSASHA1NSEC3SHA1 = 7
    RSASHA256        = 8
    RSASHA512        = 10
    ECCGOST          = 12
    ECDSAP256SHA256  = 13
    ECDSAP384SHA384  = 14
    INDIRECT         = 252
    PRIVATEDNS       = 253 // Private (experimental keys)
    PRIVATEOID       = 254
)
    DNSSEC encryption algorithm codes.

const (
    SHA1   // RFC 4034
    SHA256 // RFC 4509
    GOST94 // RFC 5933
    SHA384 // Experimental
    SHA512 // Experimental
)
    DNSSEC hashing algorithm codes.

const (
    SEP    = 1
    ZONE   = 1 << 7
    REVOKE = 1 << 8
)
    DNSKEY flag values.

const (
    EDNS0LLQ         = 0x1    // long lived queries: http://tools.ietf.org/html/draft-sekar-dns-llq-01
    EDNS0UL          = 0x2    // update lease draft: http://files.dns-sd.org/draft-sekar-dns-ul.txt
    EDNS0NSID        = 0x3    // nsid (RFC5001)
    EDNS0DAU         = 0x5    // DNSSEC Algorithm Understood
    EDNS0DHU         = 0x6    // DS Hash Understood
    EDNS0N3U         = 0x7    // NSEC3 Hash Understood
    EDNS0SUBNET      = 0x8    // client-subnet (RFC6891)
    EDNS0SUBNETDRAFT = 0x50fa // client-subnet draft: http://tools.ietf.org/html/draft-vandergaast-edns-client-subnet-01

)
    EDNS0 Option codes.

const (
    HmacMD5    = "hmac-md5.sig-alg.reg.int."
    HmacSHA1   = "hmac-sha1."
    HmacSHA256 = "hmac-sha256."
)
    HMAC hashing codes. These are transmitted as domain names.

const (
    // valid RR_Header.Rrtype and Question.qtype
    TypeNone       uint16 = 0
    TypeA          uint16 = 1
    TypeNS         uint16 = 2
    TypeMD         uint16 = 3
    TypeMF         uint16 = 4
    TypeCNAME      uint16 = 5
    TypeSOA        uint16 = 6
    TypeMB         uint16 = 7
    TypeMG         uint16 = 8
    TypeMR         uint16 = 9
    TypeNULL       uint16 = 10
    TypeWKS        uint16 = 11
    TypePTR        uint16 = 12
    TypeHINFO      uint16 = 13
    TypeMINFO      uint16 = 14
    TypeMX         uint16 = 15
    TypeTXT        uint16 = 16
    TypeRP         uint16 = 17
    TypeAFSDB      uint16 = 18
    TypeX25        uint16 = 19
    TypeISDN       uint16 = 20
    TypeRT         uint16 = 21
    TypeNSAP       uint16 = 22
    TypeNSAPPTR    uint16 = 23
    TypeSIG        uint16 = 24
    TypeKEY        uint16 = 25
    TypePX         uint16 = 26
    TypeGPOS       uint16 = 27
    TypeAAAA       uint16 = 28
    TypeLOC        uint16 = 29
    TypeNXT        uint16 = 30
    TypeEID        uint16 = 31
    TypeNIMLOC     uint16 = 32
    TypeSRV        uint16 = 33
    TypeATMA       uint16 = 34
    TypeNAPTR      uint16 = 35
    TypeKX         uint16 = 36
    TypeCERT       uint16 = 37
    TypeDNAME      uint16 = 39
    TypeOPT        uint16 = 41 // EDNS
    TypeDS         uint16 = 43
    TypeSSHFP      uint16 = 44
    TypeIPSECKEY   uint16 = 45
    TypeRRSIG      uint16 = 46
    TypeNSEC       uint16 = 47
    TypeDNSKEY     uint16 = 48
    TypeDHCID      uint16 = 49
    TypeNSEC3      uint16 = 50
    TypeNSEC3PARAM uint16 = 51
    TypeTLSA       uint16 = 52
    TypeHIP        uint16 = 55
    TypeNINFO      uint16 = 56
    TypeRKEY       uint16 = 57
    TypeTALINK     uint16 = 58
    TypeCDS        uint16 = 59
    TypeSPF        uint16 = 99
    TypeUINFO      uint16 = 100
    TypeUID        uint16 = 101
    TypeGID        uint16 = 102
    TypeUNSPEC     uint16 = 103
    TypeNID        uint16 = 104
    TypeL32        uint16 = 105
    TypeL64        uint16 = 106
    TypeLP         uint16 = 107
    TypeEUI48      uint16 = 108
    TypeEUI64      uint16 = 109

    TypeTKEY uint16 = 249
    TypeTSIG uint16 = 250
    // valid Question.Qtype only
    TypeIXFR  uint16 = 251
    TypeAXFR  uint16 = 252
    TypeMAILB uint16 = 253
    TypeMAILA uint16 = 254
    TypeANY   uint16 = 255

    TypeURI      uint16 = 256
    TypeCAA      uint16 = 257
    TypeTA       uint16 = 32768
    TypeDLV      uint16 = 32769
    TypeReserved uint16 = 65535

    // valid Question.Qclass
    ClassINET   = 1
    ClassCSNET  = 2
    ClassCHAOS  = 3
    ClassHESIOD = 4
    ClassNONE   = 254
    ClassANY    = 255

    // Msg.rcode
    RcodeSuccess        = 0
    RcodeFormatError    = 1
    RcodeServerFailure  = 2
    RcodeNameError      = 3
    RcodeNotImplemented = 4
    RcodeRefused        = 5
    RcodeYXDomain       = 6
    RcodeYXRrset        = 7
    RcodeNXRrset        = 8
    RcodeNotAuth        = 9
    RcodeNotZone        = 10
    RcodeBadSig         = 16 // TSIG
    RcodeBadVers        = 16 // EDNS0
    RcodeBadKey         = 17
    RcodeBadTime        = 18
    RcodeBadMode        = 19 // TKEY
    RcodeBadName        = 20
    RcodeBadAlg         = 21
    RcodeBadTrunc       = 22 // TSIG

    // Opcode
    OpcodeQuery  = 0
    OpcodeIQuery = 1
    OpcodeStatus = 2
    // There is no 3
    OpcodeNotify = 4
    OpcodeUpdate = 5
)
    Wire constants and supported types.


VARIABLES

var (
    ErrFqdn      error = &Error{err: "domain must be fully qualified"}
    ErrId        error = &Error{err: "id mismatch"}
    ErrRdata     error = &Error{err: "bad rdata"}
    ErrBuf       error = &Error{err: "buffer size too small"}
    ErrShortRead error = &Error{err: "short read"}
    ErrConn      error = &Error{err: "conn holds both UDP and TCP connection"}
    ErrConnEmpty error = &Error{err: "conn has no connection"}
    ErrServ      error = &Error{err: "no servers could be reached"}
    ErrKey       error = &Error{err: "bad key"}
    ErrPrivKey   error = &Error{err: "bad private key"}
    ErrKeySize   error = &Error{err: "bad key size"}
    ErrKeyAlg    error = &Error{err: "bad key algorithm"}
    ErrAlg       error = &Error{err: "bad algorithm"}
    ErrTime      error = &Error{err: "bad time"}
    ErrNoSig     error = &Error{err: "no signature found"}
    ErrSig       error = &Error{err: "bad signature"}
    ErrSecret    error = &Error{err: "no secrets defined"}
    ErrSigGen    error = &Error{err: "bad signature generation"}
    ErrAuth      error = &Error{err: "bad authentication"}
    ErrSoa       error = &Error{err: "no SOA"}
    ErrRRset     error = &Error{err: "bad rrset"}
)

var AlgorithmToString = map[uint8]string{
    RSAMD5:           "RSAMD5",
    DH:               "DH",
    DSA:              "DSA",
    RSASHA1:          "RSASHA1",
    DSANSEC3SHA1:     "DSA-NSEC3-SHA1",
    RSASHA1NSEC3SHA1: "RSASHA1-NSEC3-SHA1",
    RSASHA256:        "RSASHA256",
    RSASHA512:        "RSASHA512",
    ECCGOST:          "ECC-GOST",
    ECDSAP256SHA256:  "ECDSAP256SHA256",
    ECDSAP384SHA384:  "ECDSAP384SHA384",
    INDIRECT:         "INDIRECT",
    PRIVATEDNS:       "PRIVATEDNS",
    PRIVATEOID:       "PRIVATEOID",
}
    Map for algorithm names.

var ClassToString = map[uint16]string{
    ClassINET:   "IN",
    ClassCSNET:  "CS",
    ClassCHAOS:  "CH",
    ClassHESIOD: "HS",
    ClassNONE:   "NONE",
    ClassANY:    "ANY",
}
    Map of strings for each CLASS wire type.

var DefaultServeMux = NewServeMux()
    DefaultServeMux is the default ServeMux used by Serve.

var HashToString = map[uint8]string{
    SHA1:   "SHA1",
    SHA256: "SHA256",
    GOST94: "GOST94",
    SHA384: "SHA384",
    SHA512: "SHA512",
}
    Map for hash names.

var OpcodeToString = map[int]string{
    OpcodeQuery:  "QUERY",
    OpcodeIQuery: "IQUERY",
    OpcodeStatus: "STATUS",
    OpcodeNotify: "NOTIFY",
    OpcodeUpdate: "UPDATE",
}
    Map of strings for opcodes.

var RcodeToString = map[int]string{
    RcodeSuccess:        "NOERROR",
    RcodeFormatError:    "FORMERR",
    RcodeServerFailure:  "SERVFAIL",
    RcodeNameError:      "NXDOMAIN",
    RcodeNotImplemented: "NOTIMPL",
    RcodeRefused:        "REFUSED",
    RcodeYXDomain:       "YXDOMAIN",
    RcodeYXRrset:        "YXRRSET",
    RcodeNXRrset:        "NXRRSET",
    RcodeNotAuth:        "NOTAUTH",
    RcodeNotZone:        "NOTZONE",
    RcodeBadSig:         "BADSIG",

    RcodeBadKey:   "BADKEY",
    RcodeBadTime:  "BADTIME",
    RcodeBadMode:  "BADMODE",
    RcodeBadName:  "BADNAME",
    RcodeBadAlg:   "BADALG",
    RcodeBadTrunc: "BADTRUNC",
}
    Map of strings for rcodes.

var StringToAlgorithm = reverseInt8(AlgorithmToString)
    Map of algorithm strings.

var StringToClass = reverseInt16(ClassToString)

var StringToHash = reverseInt8(HashToString)
    Map of hash strings.

var StringToOpcode = reverseInt(OpcodeToString)
    Map of opcodes strings.

var StringToRcode = reverseInt(RcodeToString)
    Map of rcodes strings.

var StringToType = reverseInt16(TypeToString)
    Reverse, needed for string parsing.

var TypeToString = map[uint16]string{
    TypeA:          "A",
    TypeAAAA:       "AAAA",
    TypeAFSDB:      "AFSDB",
    TypeANY:        "ANY",
    TypeATMA:       "ATMA",
    TypeAXFR:       "AXFR",
    TypeCAA:        "CAA",
    TypeCDS:        "CDS",
    TypeCERT:       "CERT",
    TypeCNAME:      "CNAME",
    TypeDHCID:      "DHCID",
    TypeDLV:        "DLV",
    TypeDNAME:      "DNAME",
    TypeDNSKEY:     "DNSKEY",
    TypeDS:         "DS",
    TypeEID:        "EID",
    TypeEUI48:      "EUI48",
    TypeEUI64:      "EUI64",
    TypeGID:        "GID",
    TypeGPOS:       "GPOS",
    TypeHINFO:      "HINFO",
    TypeHIP:        "HIP",
    TypeIPSECKEY:   "IPSECKEY",
    TypeISDN:       "ISDN",
    TypeIXFR:       "IXFR",
    TypeKX:         "KX",
    TypeL32:        "L32",
    TypeL64:        "L64",
    TypeLOC:        "LOC",
    TypeLP:         "LP",
    TypeMB:         "MB",
    TypeMD:         "MD",
    TypeMF:         "MF",
    TypeMG:         "MG",
    TypeMINFO:      "MINFO",
    TypeMR:         "MR",
    TypeMX:         "MX",
    TypeNAPTR:      "NAPTR",
    TypeNID:        "NID",
    TypeNINFO:      "NINFO",
    TypeNIMLOC:     "NIMLOC",
    TypeNS:         "NS",
    TypeNSAP:       "NSAP",
    TypeNSAPPTR:    "NSAP-PTR",
    TypeNSEC3:      "NSEC3",
    TypeNSEC3PARAM: "NSEC3PARAM",
    TypeNSEC:       "NSEC",
    TypeNULL:       "NULL",
    TypeOPT:        "OPT",
    TypePTR:        "PTR",
    TypeRKEY:       "RKEY",
    TypeRP:         "RP",
    TypeRRSIG:      "RRSIG",
    TypeRT:         "RT",
    TypeSOA:        "SOA",
    TypeSPF:        "SPF",
    TypeSRV:        "SRV",
    TypeSSHFP:      "SSHFP",
    TypeTA:         "TA",
    TypeTALINK:     "TALINK",
    TypeTKEY:       "TKEY",
    TypeTLSA:       "TLSA",
    TypeTSIG:       "TSIG",
    TypeTXT:        "TXT",
    TypePX:         "PX",
    TypeUID:        "UID",
    TypeUINFO:      "UINFO",
    TypeUNSPEC:     "UNSPEC",
    TypeURI:        "URI",
    TypeWKS:        "WKS",
    TypeX25:        "X25",
}
    Map of strings for each RR wire type.


FUNCTIONS

func CertificateToDANE(selector, matchingType uint8, cert *x509.Certificate) (string, error)
    CertificateToDANE converts a certificate to a hex string as used in the
    TLSA record.

func CompareDomainName(s1, s2 string) (n int)
    CompareDomainName compares the names s1 and s2 and returns how many
    labels they have in common starting from the *right*. The comparison
    stops at the first inequality. The names are not downcased before the
    comparison.

    www.miek.nl. and miek.nl. have two labels in common: miek and nl
    www.miek.nl. and www.bla.nl. have one label in common: nl

func CountLabel(s string) (labels int)
    CountLabel counts the the number of labels in the string s.

func Fqdn(s string) string
    Fqdns return the fully qualified domain name from s. If s is already
    fully qualified, it behaves as the identity function.

func Handle(pattern string, handler Handler)
    Handle registers the handler with the given pattern in the
    DefaultServeMux. The documentation for ServeMux explains how patterns
    are matched.

func HandleFailed(w ResponseWriter, r *Msg)
    FailedHandler returns a HandlerFunc returns SERVFAIL for every request
    it gets.

func HandleFunc(pattern string, handler func(ResponseWriter, *Msg))
    HandleFunc registers the handler function with the given pattern in the
    DefaultServeMux.

func HandleRemove(pattern string)
    HandleRemove deregisters the handle with the given pattern in the
    DefaultServeMux.

func HashName(label string, ha uint8, iter uint16, salt string) string
    HashName hashes a string (label) according to RFC 5155. It returns the
    hashed string.

func Id() uint16
    Id return a 16 bits random number to be used as a message id. The random
    provided should be good enough.

func IsDomainName(s string) (labels int, ok bool)
    IsDomainName checks if s is a valid domainname, it returns the number of
    labels and true, when a domain name is valid. Note that non fully
    qualified domain name is considered valid, in this case the last label
    is counted in the number of labels. When false is returned the number of
    labels is not defined.

func IsFqdn(s string) bool
    IsFqdn checks if a domain name is fully qualified.

func IsSubDomain(parent, child string) bool
    IsSubDomain checks if child is indeed a child of the parent. Both child
    and parent are *not* downcased before doing the comparison.

func ListenAndServe(addr string, network string, handler Handler) error
    Start a server on addresss and network speficied. Invoke handler for
    incoming queries.

func NextLabel(s string, offset int) (i int, end bool)
    NextLabel returns the index of the start of the next label in the string
    s starting at offset. The bool end is true when the end of the string
    has been reached.

func PackDomainName(s string, msg []byte, off int, compression map[string]int, compress bool) (off1 int, err error)
    PackDomainName packs a domain name s into msg[off:]. If compression is
    wanted compress must be true and the compression map needs to hold a
    mapping between domain names and offsets pointing into msg[].

func PackRR(rr RR, msg []byte, off int, compression map[string]int, compress bool) (off1 int, err error)
    PackRR packs a resource record rr into msg[off:]. See PackDomainName for
    documentation about the compression.

func PackStruct(any interface{}, msg []byte, off int) (off1 int, err error)
    PackStruct packs any structure to wire format.

func ParseZone(r io.Reader, origin, file string) chan *Token
    ParseZone reads a RFC 1035 style one from r. It returns *Tokens on the
    returned channel, which consist out the parsed RR, a potential comment
    or an error. If there is an error the RR is nil. The string file is only
    used in error reporting. The string origin is used as the initial
    origin, as if the file would start with: $ORIGIN origin . The directives
    $INCLUDE, $ORIGIN, $TTL and $GENERATE are supported. The channel t is
    closed by ParseZone when the end of r is reached.

    Basic usage pattern when reading from a string (z) containing the zone
    data:

	for x := range dns.ParseZone(strings.NewReader(z), "", "") {
		if x.Error != nil {
			// Do something with x.RR
		}
	}

    Comments specified after an RR (and on the same line!) are returned too:

	foo. IN A 10.0.0.1 ; this is a comment

    The text "; this is comment" is returned in Token.Comment . Comments
    inside the RR are discarded. Comments on a line by themselves are
    discarded too.

func PrevLabel(s string, n int) (i int, start bool)
    PrevLabel returns the index of the label when starting from the right
    and jumping n labels to the left. The bool start is true when the start
    of the string has been overshot.

func ReverseAddr(addr string) (arpa string, err error)
    ReverseAddr returns the in-addr.arpa. or ip6.arpa. hostname of the IP
    address suitable for reverse DNS (PTR) record lookups or an error if it
    fails to parse the IP address.

func Split(s string) []int
    Split splits a name s into its label indexes. www.miek.nl. returns
    []int{0, 4, 9}, www.miek.nl also returns []int{0, 4, 9}. The root name
    (.) returns nil.

func SplitDomainName(s string) (labels []string)
    SplitDomainName splits a name string into it's labels. www.miek.nl.
    returns []string{"www", "miek", "nl"} The root label (.) returns nil.

func StringToTime(s string) (uint32, error)
    StringToTime translates the RRSIG's incep. and expir. times from string
    values like "20110403154150" to an 32 bit integer. It takes serial
    arithmetic (RFC 1982) into account.

func TLSAName(name, service, network string) (string, error)
    TLSAName returns the ownername of a TLSA resource record as per the
    rules specified in RFC 6698, Section 3.

func TimeToString(t uint32) string
    TimeToString translates the RRSIG's incep. and expir. times to the
    string representation used when printing the record. It takes serial
    arithmetic (RFC 1982) into account.

func TsigGenerate(m *Msg, secret, requestMAC string, timersOnly bool) ([]byte, string, error)
    TsigGenerate fills out the TSIG record attached to the message. The
    message should contain a "stub" TSIG RR with the algorithm, key name
    (owner name of the RR), time fudge (defaults to 300 seconds) and the
    current time The TSIG MAC is saved in that Tsig RR. When TsigGenerate is
    called for the first time requestMAC is set to the empty string and
    timersOnly is false. If something goes wrong an error is returned,
    otherwise it is nil.

func TsigVerify(msg []byte, secret, requestMAC string, timersOnly bool) error
    TsigVerify verifies the TSIG on a message. If the signature does not
    validate err contains the error, otherwise it is nil.

func UnpackDomainName(msg []byte, off int) (string, int, error)
    UnpackDomainName unpacks a domain name into a string.

func UnpackStruct(any interface{}, msg []byte, off int) (off1 int, err error)
    UnpackStruct unpacks a binary message from offset off to the interface
    value given.


TYPES

type A struct {
    Hdr RR_Header
    A   net.IP `dns:"a"`
}


func (rr *A) Header() *RR_Header

func (rr *A) String() string


type AAAA struct {
    Hdr  RR_Header
    AAAA net.IP `dns:"aaaa"`
}


func (rr *AAAA) Header() *RR_Header

func (rr *AAAA) String() string


type AFSDB struct {
    Hdr      RR_Header
    Subtype  uint16
    Hostname string `dns:"cdomain-name"`
}


func (rr *AFSDB) Header() *RR_Header

func (rr *AFSDB) String() string


type ANY struct {
    Hdr RR_Header
}


func (rr *ANY) Header() *RR_Header

func (rr *ANY) String() string


type CDS struct {
    Hdr        RR_Header
    KeyTag     uint16
    Algorithm  uint8
    DigestType uint8
    Digest     string `dns:"hex"`
}


func (rr *CDS) Header() *RR_Header

func (rr *CDS) String() string


type CERT struct {
    Hdr         RR_Header
    Type        uint16
    KeyTag      uint16
    Algorithm   uint8
    Certificate string `dns:"base64"`
}
    See RFC 4398.


func (rr *CERT) Header() *RR_Header

func (rr *CERT) String() string


type CNAME struct {
    Hdr    RR_Header
    Target string `dns:"cdomain-name"`
}


func (rr *CNAME) Header() *RR_Header

func (rr *CNAME) String() string


type Class uint16


func (c Class) String() string
    String returns the string representation for the class c


type Client struct {
    Net            string            // if "tcp" a TCP query will be initiated, otherwise an UDP one (default is "" for UDP)
    UDPSize        uint16            // Minimum receive buffer for UDP messages
    DialTimeout    time.Duration     // net.DialTimeout (ns), defaults to 2 * 1e9
    ReadTimeout    time.Duration     // net.Conn.SetReadTimeout value for connections (ns), defaults to 2 * 1e9
    WriteTimeout   time.Duration     // net.Conn.SetWriteTimeout value for connections (ns), defaults to 2 * 1e9
    TsigSecret     map[string]string // secret(s) for Tsig map[<zonename>]<base64 secret>, zonename must be fully qualified
    SingleInflight bool              // if true suppress multiple outstanding queries for the same Qname, Qtype and Qclass
    // contains filtered or unexported fields
}
    A Client defines parameters for a DNS client.


func (c *Client) Exchange(m *Msg, a string) (r *Msg, rtt time.Duration, err error)
    Exchange performs an synchronous query. It sends the message m to the
    address contained in a and waits for an reply. Basic use pattern with a
    *dns.Client:

	c := new(dns.Client)
	in, rtt, err := c.Exchange(message, "127.0.0.1:53")

    Exchange does not retry a failed query, nor will it fall back to TCP in
    case of truncation.


type ClientConfig struct {
    Servers  []string // servers to use
    Search   []string // suffixes to append to local name
    Port     string   // what port to use
    Ndots    int      // number of dots in name to trigger absolute lookup
    Timeout  int      // seconds before giving up on packet
    Attempts int      // lost packets before giving up on server, not used in the package dns
}
    Wraps the contents of the /etc/resolv.conf.


func ClientConfigFromFile(resolvconf string) (*ClientConfig, error)
    ClientConfigFromFile parses a resolv.conf(5) like file and returns a
    *ClientConfig.



type Conn struct {
    net.Conn                     // a net.Conn holding the connection
    UDPSize    uint16            // Minimum receive buffer for UDP messages
    TsigSecret map[string]string // Secret(s) for Tsig map[<zonename>]<base64 secret>, zonename must be fully qualified
    // contains filtered or unexported fields
}
    A Conn represents a connection to a DNS server.


func Dial(network, address string) (conn *Conn, err error)
    Dial connects to the address on the named network.


func DialTimeout(network, address string, timeout time.Duration) (conn *Conn, err error)
    Dialtimeout acts like Dial but takes a timeout.


func (co *Conn) Close() error
    Close implements the net.Conn Close method.

func (co *Conn) LocalAddr() net.Addr
    LocalAddr implements the net.Conn LocalAddr method.

func (co *Conn) Read(p []byte) (n int, err error)
    Read implements the net.Conn read method.

func (co *Conn) ReadMsg() (*Msg, error)
    ReadMsg reads a message from the connection co. If the received message
    contains a TSIG record the transaction signature is verified.

func (co *Conn) RemoteAddr() net.Addr
    RemoteAddr implements the net.Conn RemoteAddr method.

func (co *Conn) SetDeadline(t time.Time) error
    SetDeadline implements the net.Conn SetDeadline method.

func (co *Conn) SetReadDeadline(t time.Time) error
    SetReadDeadline implements the net.Conn SetReadDeadline method.

func (co *Conn) SetWriteDeadline(t time.Time) error
    SetWriteDeadline implements the net.Conn SetWriteDeadline method.

func (co *Conn) Write(p []byte) (n int, err error)
    Write implements the net.Conn Write method.

func (co *Conn) WriteMsg(m *Msg) (err error)
    WriteMsg sends a message throught the connection co. If the message m
    contains a TSIG record the transaction signature is calculated.


type DHCID struct {
    Hdr    RR_Header
    Digest string `dns:"base64"`
}


func (rr *DHCID) Header() *RR_Header

func (rr *DHCID) String() string


type DLV struct {
    Hdr        RR_Header
    KeyTag     uint16
    Algorithm  uint8
    DigestType uint8
    Digest     string `dns:"hex"`
}


func (rr *DLV) Header() *RR_Header

func (rr *DLV) String() string


type DNAME struct {
    Hdr    RR_Header
    Target string `dns:"domain-name"`
}
    See RFC 2672.


func (rr *DNAME) Header() *RR_Header

func (rr *DNAME) String() string


type DNSKEY struct {
    Hdr       RR_Header
    Flags     uint16
    Protocol  uint8
    Algorithm uint8
    PublicKey string `dns:"base64"`
}


func (r *DNSKEY) Generate(bits int) (PrivateKey, error)
    Generate generates a DNSKEY of the given bit size. The public part is
    put inside the DNSKEY record. The Algorithm in the key must be set as
    this will define what kind of DNSKEY will be generated. The ECDSA
    algorithms imply a fixed keysize, in that case bits should be set to the
    size of the algorithm.

func (rr *DNSKEY) Header() *RR_Header

func (k *DNSKEY) KeyTag() uint16
    KeyTag calculates the keytag (or key-id) of the DNSKEY.

func (k *DNSKEY) NewPrivateKey(s string) (PrivateKey, error)

func (r *DNSKEY) PrivateKeyString(p PrivateKey) (s string)
    PrivateKeyString converts a PrivateKey to a string. This string has the
    same format as the private-key-file of BIND9 (Private-key-format: v1.3).
    It needs some info from the key (hashing, keytag), so its a method of
    the DNSKEY.

func (k *DNSKEY) ReadPrivateKey(q io.Reader, file string) (PrivateKey, error)
    ReadPrivateKey reads a private key from the io.Reader q. The string file
    is only used in error reporting. The public key must be known, because
    some cryptographic algorithms embed the public inside the privatekey.

func (rr *DNSKEY) String() string

func (k *DNSKEY) ToDS(h int) *DS
    ToDS converts a DNSKEY record to a DS record.


type DS struct {
    Hdr        RR_Header
    KeyTag     uint16
    Algorithm  uint8
    DigestType uint8
    Digest     string `dns:"hex"`
}


func (rr *DS) Header() *RR_Header

func (rr *DS) String() string


type Denialer interface {
    // Cover will check if the (unhashed) name is being covered by this NSEC or NSEC3.
    Cover(name string) bool
    // Match will check if the ownername matches the (unhashed) name for this NSEC3 or NSEC3.
    Match(name string) bool
}



type EDNS0 interface {
    // Option returns the option code for the option.
    Option() uint16

    // String returns the string representation of the option.
    String() string
    // contains filtered or unexported methods
}
    EDNS0 defines an EDNS0 Option. An OPT RR can have multiple options
    appended to it.



type EDNS0_DAU struct {
    Code    uint16 // Always EDNS0DAU
    AlgCode []uint8
}


func (e *EDNS0_DAU) Option() uint16

func (e *EDNS0_DAU) String() string


type EDNS0_DHU struct {
    Code    uint16 // Always EDNS0DHU
    AlgCode []uint8
}


func (e *EDNS0_DHU) Option() uint16

func (e *EDNS0_DHU) String() string


type EDNS0_LLQ struct {
    Code      uint16 // Always EDNS0LLQ
    Version   uint16
    Opcode    uint16
    Error     uint16
    Id        uint64
    LeaseLife uint32
}
    Long Lived Queries: http://tools.ietf.org/html/draft-sekar-dns-llq-01
    Implemented for completeness, as the EDNS0 type code is assigned.


func (e *EDNS0_LLQ) Option() uint16

func (e *EDNS0_LLQ) String() string


type EDNS0_N3U struct {
    Code    uint16 // Always EDNS0N3U
    AlgCode []uint8
}


func (e *EDNS0_N3U) Option() uint16

func (e *EDNS0_N3U) String() string


type EDNS0_NSID struct {
    Code uint16 // Always EDNS0NSID
    Nsid string // This string needs to be hex encoded
}
    The nsid EDNS0 option is used to retrieve a nameserver identifier. When
    sending a request Nsid must be set to the empty string The identifier is
    an opaque string encoded as hex. Basic use pattern for creating an nsid
    option:

	o := new(dns.OPT)
	o.Hdr.Name = "."
	o.Hdr.Rrtype = dns.TypeOPT
	e := new(dns.EDNS0_NSID)
	e.Code = dns.EDNS0NSID
	o.Option = append(o.Option, e)


func (e *EDNS0_NSID) Option() uint16

func (e *EDNS0_NSID) String() string


type EDNS0_SUBNET struct {
    Code          uint16 // Always EDNS0SUBNET
    Family        uint16 // 1 for IP, 2 for IP6
    SourceNetmask uint8
    SourceScope   uint8
    Address       net.IP
    DraftOption   bool // Set to true if using the old (0x50fa) option code
}
    The subnet EDNS0 option is used to give the remote nameserver an idea of
    where the client lives. It can then give back a different answer
    depending on the location or network topology. Basic use pattern for
    creating an subnet option:

	o := new(dns.OPT)
	o.Hdr.Name = "."
	o.Hdr.Rrtype = dns.TypeOPT
	e := new(dns.EDNS0_SUBNET)
	e.Code = dns.EDNS0SUBNET
	e.Family = 1	// 1 for IPv4 source address, 2 for IPv6
	e.NetMask = 32	// 32 for IPV4, 128 for IPv6
	e.SourceScope = 0
	e.Address = net.ParseIP("127.0.0.1").To4()	// for IPv4
	// e.Address = net.ParseIP("2001:7b8:32a::2")	// for IPV6
	o.Option = append(o.Option, e)


func (e *EDNS0_SUBNET) Option() uint16

func (e *EDNS0_SUBNET) String() (s string)


type EDNS0_UL struct {
    Code  uint16 // Always EDNS0UL
    Lease uint32
}
    The UL (Update Lease) EDNS0 (draft RFC) option is used to tell the
    server to set an expiration on an update RR. This is helpful for clients
    that cannot clean up after themselves. This is a draft RFC and more
    information can be found at
    http://files.dns-sd.org/draft-sekar-dns-ul.txt

	o := new(dns.OPT)
	o.Hdr.Name = "."
	o.Hdr.Rrtype = dns.TypeOPT
	e := new(dns.EDNS0_UL)
	e.Code = dns.EDNS0UL
	e.Lease = 120 // in seconds
	o.Option = append(o.Option, e)


func (e *EDNS0_UL) Option() uint16

func (e *EDNS0_UL) String() string


type EID struct {
    Hdr      RR_Header
    Endpoint string `dns:"hex"`
}


func (rr *EID) Header() *RR_Header

func (rr *EID) String() string


type EUI48 struct {
    Hdr     RR_Header
    Address uint64 `dns:"uint48"`
}


func (rr *EUI48) Header() *RR_Header

func (rr *EUI48) String() string


type EUI64 struct {
    Hdr     RR_Header
    Address uint64
}


func (rr *EUI64) Header() *RR_Header

func (rr *EUI64) String() string


type Envelope struct {
    RR    []RR  // The set of RRs in the answer section of the xfr reply message.
    Error error // If something went wrong, this contains the error.
}
    Envelope is used when doing a zone transfer with a remote server.



type Error struct {
    // contains filtered or unexported fields
}
    Error represents a DNS error


func (e *Error) Error() string


type GID struct {
    Hdr RR_Header
    Gid uint32
}


func (rr *GID) Header() *RR_Header

func (rr *GID) String() string


type GPOS struct {
    Hdr       RR_Header
    Longitude string
    Latitude  string
    Altitude  string
}


func (rr *GPOS) Header() *RR_Header

func (rr *GPOS) String() string


type HINFO struct {
    Hdr RR_Header
    Cpu string
    Os  string
}


func (rr *HINFO) Header() *RR_Header

func (rr *HINFO) String() string


type HIP struct {
    Hdr                RR_Header
    HitLength          uint8
    PublicKeyAlgorithm uint8
    PublicKeyLength    uint16
    Hit                string   `dns:"hex"`
    PublicKey          string   `dns:"base64"`
    RendezvousServers  []string `dns:"domain-name"`
}


func (rr *HIP) Header() *RR_Header

func (rr *HIP) String() string


type Handler interface {
    ServeDNS(w ResponseWriter, r *Msg)
}



type HandlerFunc func(ResponseWriter, *Msg)
    The HandlerFunc type is an adapter to allow the use of ordinary
    functions as DNS handlers. If f is a function with the appropriate
    signature, HandlerFunc(f) is a Handler object that calls f.


func (f HandlerFunc) ServeDNS(w ResponseWriter, r *Msg)
    ServerDNS calls f(w, r)


type Header struct {
    Id                                 uint16
    Bits                               uint16
    Qdcount, Ancount, Nscount, Arcount uint16
}
    The wire format for the DNS packet header.



type IPSECKEY struct {
    Hdr         RR_Header
    Precedence  uint8
    GatewayType uint8
    Algorithm   uint8
    Gateway     string `dns:"ipseckey"`
    PublicKey   string `dns:"base64"`
}


func (rr *IPSECKEY) Header() *RR_Header

func (rr *IPSECKEY) String() string


type KX struct {
    Hdr        RR_Header
    Preference uint16
    Exchanger  string `dns:"domain-name"`
}


func (rr *KX) Header() *RR_Header

func (rr *KX) String() string


type L32 struct {
    Hdr        RR_Header
    Preference uint16
    Locator32  net.IP `dns:"a"`
}


func (rr *L32) Header() *RR_Header

func (rr *L32) String() string


type L64 struct {
    Hdr        RR_Header
    Preference uint16
    Locator64  uint64
}


func (rr *L64) Header() *RR_Header

func (rr *L64) String() string


type LOC struct {
    Hdr       RR_Header
    Version   uint8
    Size      uint8
    HorizPre  uint8
    VertPre   uint8
    Latitude  uint32
    Longitude uint32
    Altitude  uint32
}


func (rr *LOC) Header() *RR_Header

func (rr *LOC) String() string


type LP struct {
    Hdr        RR_Header
    Preference uint16
    Fqdn       string `dns:"domain-name"`
}


func (rr *LP) Header() *RR_Header

func (rr *LP) String() string


type MB struct {
    Hdr RR_Header
    Mb  string `dns:"cdomain-name"`
}


func (rr *MB) Header() *RR_Header

func (rr *MB) String() string


type MD struct {
    Hdr RR_Header
    Md  string `dns:"cdomain-name"`
}


func (rr *MD) Header() *RR_Header

func (rr *MD) String() string


type MF struct {
    Hdr RR_Header
    Mf  string `dns:"cdomain-name"`
}


func (rr *MF) Header() *RR_Header

func (rr *MF) String() string


type MG struct {
    Hdr RR_Header
    Mg  string `dns:"cdomain-name"`
}


func (rr *MG) Header() *RR_Header

func (rr *MG) String() string


type MINFO struct {
    Hdr   RR_Header
    Rmail string `dns:"cdomain-name"`
    Email string `dns:"cdomain-name"`
}


func (rr *MINFO) Header() *RR_Header

func (rr *MINFO) String() string


type MR struct {
    Hdr RR_Header
    Mr  string `dns:"cdomain-name"`
}


func (rr *MR) Header() *RR_Header

func (rr *MR) String() string


type MX struct {
    Hdr        RR_Header
    Preference uint16
    Mx         string `dns:"cdomain-name"`
}


func (rr *MX) Header() *RR_Header

func (rr *MX) String() string


type Msg struct {
    MsgHdr
    Compress bool       `json:"-"` // If true, the message will be compressed when converted to wire format. This not part of the official DNS packet format.
    Question []Question // Holds the RR(s) of the question section.
    Answer   []RR       // Holds the RR(s) of the answer section.
    Ns       []RR       // Holds the RR(s) of the authority section.
    Extra    []RR       // Holds the RR(s) of the additional section.
}
    The layout of a DNS message.


func Exchange(m *Msg, a string) (r *Msg, err error)
    Exchange performs a synchronous UDP query. It sends the message m to the
    address contained in a and waits for an reply. Exchange does not retry a
    failed query, nor will it fall back to TCP in case of truncation.


func ExchangeConn(c net.Conn, m *Msg) (r *Msg, err error)
    ExchangeConn performs a synchronous query. It sends the message m via
    the connection c and waits for a reply. The connection c is not closed
    by ExchangeConn. This function is going away, but can easily be
    mimicked:

	co := &dns.Conn{Conn: c} // c is your net.Conn
	co.WriteMsg(m)
	in, _  := co.ReadMsg()
	co.Close()


func (dns *Msg) Copy() *Msg
    Copy returns a new *Msg which is a deep-copy of dns.

func (u *Msg) Insert(rr []RR)
    Insert creates a dynamic update packet that adds an complete RRset, see
    RFC 2136 section 2.5.1.

func (dns *Msg) IsEdns0() *OPT
    IsEdns0 checks if the message has a EDNS0 (OPT) record, any EDNS0 record
    in the additional section will do. It returns the OPT record found or
    nil.

func (dns *Msg) IsTsig() *TSIG
    IsTsig checks if the message has a TSIG record as the last record in the
    additional section. It returns the TSIG record found or nil.

func (dns *Msg) Len() int
    Len returns the message length when in (un)compressed wire format. If
    dns.Compress is true compression it is taken into account. Len() is
    provided to be a faster way to get the size of the resulting packet,
    than packing it, measuring the size and discarding the buffer.

func (u *Msg) NameNotUsed(rr []RR)
    NameNotUsed sets the RRs in the prereq section to "Name is in not use"
    RRs. RFC 2136 section 2.4.5.

func (u *Msg) NameUsed(rr []RR)
    NameUsed sets the RRs in the prereq section to "Name is in use" RRs. RFC
    2136 section 2.4.4.

func (dns *Msg) Pack() (msg []byte, err error)
    Pack packs a Msg: it is converted to to wire format. If the dns.Compress
    is true the message will be in compressed wire format.

func (dns *Msg) PackBuffer(buf []byte) (msg []byte, err error)
    PackBuffer packs a Msg, using the given buffer buf. If buf is too small
    a new buffer is allocated.

func (u *Msg) RRsetNotUsed(rr []RR)
    RRsetNotUsed sets the RRs in the prereq section to "RRset does not
    exist" RRs. RFC 2136 section 2.4.3.

func (u *Msg) RRsetUsed(rr []RR)
    RRsetUsed sets the RRs in the prereq section to "RRset exists (value
    independent -- no rdata)" RRs. RFC 2136 section 2.4.1.

func (u *Msg) Remove(rr []RR)
    Remove creates a dynamic update packet deletes RR from the RRSset, see
    RFC 2136 section 2.5.4

func (u *Msg) RemoveName(rr []RR)
    RemoveName creates a dynamic update packet that deletes all RRsets of a
    name, see RFC 2136 section 2.5.3

func (u *Msg) RemoveRRset(rr []RR)
    RemoveRRset creates a dynamic update packet that deletes an RRset, see
    RFC 2136 section 2.5.2.

func (dns *Msg) SetAxfr(z string) *Msg
    SetAxfr creates dns.Msg for requesting an AXFR.

func (dns *Msg) SetEdns0(udpsize uint16, do bool) *Msg
    SetEdns0 appends a EDNS0 OPT RR to the message. TSIG should always the
    last RR in a message.

func (dns *Msg) SetIxfr(z string, serial uint32) *Msg
    SetIxfr creates dns.Msg for requesting an IXFR.

func (dns *Msg) SetNotify(z string) *Msg
    SetNotify creates a notify packet.

func (dns *Msg) SetQuestion(z string, t uint16) *Msg
    SetQuestion creates a question packet.

func (dns *Msg) SetRcode(request *Msg, rcode int) *Msg
    SetRcode creates an error packet suitable for the request.

func (dns *Msg) SetRcodeFormatError(request *Msg) *Msg
    SetRcodeFormatError creates a packet with FormError set.

func (dns *Msg) SetReply(request *Msg) *Msg
    SetReply creates a reply packet from a request message.

func (dns *Msg) SetTsig(z, algo string, fudge, timesigned int64) *Msg
    SetTsig appends a TSIG RR to the message. This is only a skeleton TSIG
    RR that is added as the last RR in the additional section. The Tsig is
    calculated when the message is being send.

func (dns *Msg) SetUpdate(z string) *Msg
    SetUpdate makes the message a dynamic update packet. It sets the ZONE
    section to: z, TypeSOA, ClassINET.

func (dns *Msg) String() string
    Convert a complete message to a string with dig-like output.

func (dns *Msg) Unpack(msg []byte) (err error)
    Unpack unpacks a binary message to a Msg structure.

func (u *Msg) Used(rr []RR)
    Used sets the RRs in the prereq section to "RRset exists (value
    dependent -- with rdata)" RRs. RFC 2136 section 2.4.2.


type MsgHdr struct {
    Id                 uint16
    Response           bool
    Opcode             int
    Authoritative      bool
    Truncated          bool
    RecursionDesired   bool
    RecursionAvailable bool
    Zero               bool
    AuthenticatedData  bool
    CheckingDisabled   bool
    Rcode              int
}
    A manually-unpacked version of (id, bits). This is in its own struct for
    easy printing.


func (h *MsgHdr) String() string
    Convert a MsgHdr to a string, with dig-like headers:

    ;; opcode: QUERY, status: NOERROR, id: 48404

    ;; flags: qr aa rd ra;


type NAPTR struct {
    Hdr         RR_Header
    Order       uint16
    Preference  uint16
    Flags       string
    Service     string
    Regexp      string
    Replacement string `dns:"domain-name"`
}


func (rr *NAPTR) Header() *RR_Header

func (rr *NAPTR) String() string


type NID struct {
    Hdr        RR_Header
    Preference uint16
    NodeID     uint64
}


func (rr *NID) Header() *RR_Header

func (rr *NID) String() string


type NIMLOC struct {
    Hdr     RR_Header
    Locator string `dns:"hex"`
}


func (rr *NIMLOC) Header() *RR_Header

func (rr *NIMLOC) String() string


type NINFO struct {
    Hdr    RR_Header
    ZSData []string `dns:"txt"`
}


func (rr *NINFO) Header() *RR_Header

func (rr *NINFO) String() string


type NS struct {
    Hdr RR_Header
    Ns  string `dns:"cdomain-name"`
}


func (rr *NS) Header() *RR_Header

func (rr *NS) String() string


type NSAP struct {
    Hdr    RR_Header
    Length uint8
    Nsap   string
}


func (rr *NSAP) Header() *RR_Header

func (rr *NSAP) String() string


type NSAPPTR struct {
    Hdr RR_Header
    Ptr string `dns:"domain-name"`
}


func (rr *NSAPPTR) Header() *RR_Header

func (rr *NSAPPTR) String() string


type NSEC struct {
    Hdr        RR_Header
    NextDomain string   `dns:"domain-name"`
    TypeBitMap []uint16 `dns:"nsec"`
}


func (rr *NSEC) Cover(name string) bool
    Cover implements the Denialer interface.

func (rr *NSEC) Header() *RR_Header

func (rr *NSEC) Match(name string) bool
    Match implements the Denialer interface.

func (rr *NSEC) String() string


type NSEC3 struct {
    Hdr        RR_Header
    Hash       uint8
    Flags      uint8
    Iterations uint16
    SaltLength uint8
    Salt       string `dns:"size-hex"`
    HashLength uint8
    NextDomain string   `dns:"size-base32"`
    TypeBitMap []uint16 `dns:"nsec"`
}


func (rr *NSEC3) Cover(name string) bool
    Cover implements the Denialer interface.

func (rr *NSEC3) Header() *RR_Header

func (rr *NSEC3) Match(name string) bool
    Match implements the Denialer interface.

func (rr *NSEC3) String() string


type NSEC3PARAM struct {
    Hdr        RR_Header
    Hash       uint8
    Flags      uint8
    Iterations uint16
    SaltLength uint8
    Salt       string `dns:"hex"`
}


func (rr *NSEC3PARAM) Header() *RR_Header

func (rr *NSEC3PARAM) String() string


type OPT struct {
    Hdr    RR_Header
    Option []EDNS0 `dns:"opt"`
}


func (rr *OPT) Do() bool
    Do returns the value of the DO (DNSSEC OK) bit.

func (rr *OPT) Header() *RR_Header

func (rr *OPT) SetDo()
    SetDo sets the DO (DNSSEC OK) bit.

func (rr *OPT) SetUDPSize(size uint16)
    SetUDPSize sets the UDP buffer size.

func (rr *OPT) SetVersion(v uint8)
    SetVersion sets the version of EDNS. This is usually zero.

func (rr *OPT) String() string

func (rr *OPT) UDPSize() uint16
    UDPSize returns the UDP buffer size.

func (rr *OPT) Version() uint8
    Version returns the EDNS version used. Only zero is defined.


type PTR struct {
    Hdr RR_Header
    Ptr string `dns:"cdomain-name"`
}


func (rr *PTR) Header() *RR_Header

func (rr *PTR) String() string


type PX struct {
    Hdr        RR_Header
    Preference uint16
    Map822     string `dns:"domain-name"`
    Mapx400    string `dns:"domain-name"`
}


func (rr *PX) Header() *RR_Header

func (rr *PX) String() string


type ParseError struct {
    // contains filtered or unexported fields
}
    ParseError is a parsing error. It contains the parse error and the
    location in the io.Reader where the error occured.


func (e *ParseError) Error() (s string)


type PrivateKey interface{}
    Empty interface that is used as a wrapper around all possible private
    key implementations from the crypto package.



type Question struct {
    Name   string `dns:"cdomain-name"` // "cdomain-name" specifies encoding (and may be compressed)
    Qtype  uint16
    Qclass uint16
}
    DNS queries.


func (q *Question) String() (s string)


type RFC3597 struct {
    Hdr   RR_Header
    Rdata string `dns:"hex"`
}
    RFC3597 represents an unknown/generic RR.


func (rr *RFC3597) Header() *RR_Header

func (rr *RFC3597) String() string

func (rr *RFC3597) ToRFC3597(r RR) error
    ToRFC3597 converts a known RR to the unknown RR representation from RFC
    3597.


type RKEY struct {
    Hdr       RR_Header
    Flags     uint16
    Protocol  uint8
    Algorithm uint8
    PublicKey string `dns:"base64"`
}


func (rr *RKEY) Header() *RR_Header

func (rr *RKEY) String() string


type RP struct {
    Hdr  RR_Header
    Mbox string `dns:"domain-name"`
    Txt  string `dns:"domain-name"`
}


func (rr *RP) Header() *RR_Header

func (rr *RP) String() string


type RR interface {
    // Header returns the header of an resource record. The header contains
    // everything up to the rdata.
    Header() *RR_Header
    // String returns the text representation of the resource record.
    String() string
    // contains filtered or unexported methods
}
    An RR represents a resource record.


func Copy(r RR) RR
    Copy returns a new RR which is a deep-copy of r.


func NewRR(s string) (RR, error)
    NewRR reads the RR contained in the string s. Only the first RR is
    returned. The class defaults to IN and TTL defaults to 3600. The full
    zone file syntax like $TTL, $ORIGIN, etc. is supported.


func ReadRR(q io.Reader, filename string) (RR, error)
    ReadRR reads the RR contained in q. Only the first RR is returned. The
    class defaults to IN and TTL defaults to 3600.


func UnpackRR(msg []byte, off int) (rr RR, off1 int, err error)
    UnpackRR unpacks msg[off:] into an RR.



type RRSIG struct {
    Hdr         RR_Header
    TypeCovered uint16
    Algorithm   uint8
    Labels      uint8
    OrigTtl     uint32
    Expiration  uint32
    Inception   uint32
    KeyTag      uint16
    SignerName  string `dns:"domain-name"`
    Signature   string `dns:"base64"`
}


func (rr *RRSIG) Header() *RR_Header

func (rr *RRSIG) Sign(k PrivateKey, rrset []RR) error
    Sign signs an RRSet. The signature needs to be filled in with the
    values: Inception, Expiration, KeyTag, SignerName and Algorithm. The
    rest is copied from the RRset. Sign returns true when the signing went
    OK, otherwise false. There is no check if RRSet is a proper (RFC 2181)
    RRSet. If OrigTTL is non zero, it is used as-is, otherwise the TTL of
    the RRset is used as the OrigTTL.

func (rr *RRSIG) String() string

func (rr *RRSIG) ValidityPeriod(t time.Time) bool
    ValidityPeriod uses RFC1982 serial arithmetic to calculate if a
    signature period is valid. If t is the zero time, the current time is
    taken other t is.

func (rr *RRSIG) Verify(k *DNSKEY, rrset []RR) error
    Verify validates an RRSet with the signature and key. This is only the
    cryptographic test, the signature validity period must be checked
    separately. This function copies the rdata of some RRs (to lowercase
    domain names) for the validation to work.


type RR_Header struct {
    Name     string `dns:"cdomain-name"`
    Rrtype   uint16
    Class    uint16
    Ttl      uint32
    Rdlength uint16 // length of data after header
}
    DNS resource records. There are many types of RRs, but they all share
    the same header.


func (h *RR_Header) Header() *RR_Header

func (h *RR_Header) String() string


type RT struct {
    Hdr        RR_Header
    Preference uint16
    Host       string `dns:"cdomain-name"`
}


func (rr *RT) Header() *RR_Header

func (rr *RT) String() string


type ResponseWriter interface {
    // RemoteAddr returns the net.Addr of the client that sent the current request.
    RemoteAddr() net.Addr
    // WriteMsg writes a reply back to the client.
    WriteMsg(*Msg) error
    // Write writes a raw buffer back to the client.
    Write([]byte) (int, error)
    // Close closes the connection.
    Close() error
    // TsigStatus returns the status of the Tsig.
    TsigStatus() error
    // TsigTimersOnly sets the tsig timers only boolean.
    TsigTimersOnly(bool)
    // Hijack lets the caller take over the connection.
    // After a call to Hijack(), the DNS package will not do anything with the connection
    Hijack()
}
    A ResponseWriter interface is used by an DNS handler to construct an DNS
    response.



type SOA struct {
    Hdr     RR_Header
    Ns      string `dns:"cdomain-name"`
    Mbox    string `dns:"cdomain-name"`
    Serial  uint32
    Refresh uint32
    Retry   uint32
    Expire  uint32
    Minttl  uint32
}


func (rr *SOA) Header() *RR_Header

func (rr *SOA) String() string


type SPF struct {
    Hdr RR_Header
    Txt []string `dns:"txt"`
}


func (rr *SPF) Header() *RR_Header

func (rr *SPF) String() string


type SRV struct {
    Hdr      RR_Header
    Priority uint16
    Weight   uint16
    Port     uint16
    Target   string `dns:"domain-name"`
}


func (rr *SRV) Header() *RR_Header

func (rr *SRV) String() string


type SSHFP struct {
    Hdr         RR_Header
    Algorithm   uint8
    Type        uint8
    FingerPrint string `dns:"hex"`
}


func (rr *SSHFP) Header() *RR_Header

func (rr *SSHFP) String() string


type ServeMux struct {
    // contains filtered or unexported fields
}
    ServeMux is an DNS request multiplexer. It matches the zone name of each
    incoming request against a list of registered patterns add calls the
    handler for the pattern that most closely matches the zone name.
    ServeMux is DNSSEC aware, meaning that queries for the DS record are
    redirected to the parent zone (if that is also registered), otherwise
    the child gets the query. ServeMux is also safe for concurrent access
    from multiple goroutines.


func NewServeMux() *ServeMux
    NewServeMux allocates and returns a new ServeMux.


func (mux *ServeMux) Handle(pattern string, handler Handler)
    Handle adds a handler to the ServeMux for pattern.

func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Msg))
    Handle adds a handler to the ServeMux for pattern.

func (mux *ServeMux) HandleRemove(pattern string)
    HandleRemove deregistrars the handler specific for pattern from the
    ServeMux.

func (mux *ServeMux) ServeDNS(w ResponseWriter, request *Msg)
    ServeDNS dispatches the request to the handler whose pattern most
    closely matches the request message. If DefaultServeMux is used the
    correct thing for DS queries is done: a possible parent is sought. If no
    handler is found a standard SERVFAIL message is returned If the request
    message does not have exactly one question in the question section a
    SERVFAIL is returned.


type Server struct {
    // Address to listen on, ":dns" if empty.
    Addr string
    // if "tcp" it will invoke a TCP listener, otherwise an UDP one.
    Net string
    // Handler to invoke, dns.DefaultServeMux if nil.
    Handler Handler
    // Default buffer size to use to read incoming UDP messages. If not set
    // it defaults to MinMsgSize (512 B).
    UDPSize int
    // The net.Conn.SetReadTimeout value for new connections.
    ReadTimeout time.Duration
    // The net.Conn.SetWriteTimeout value for new connections.
    WriteTimeout time.Duration
    // TCP idle timeout for multiple queries, if nil, defaults to 8 * time.Second (RFC 5966).
    IdleTimeout func() time.Duration
    // Secret(s) for Tsig map[<zonename>]<base64 secret>.
    TsigSecret map[string]string
    // If true use a pool to recycle buffers for UDP queries.
    Pool bool
    // contains filtered or unexported fields
}
    A Server defines parameters for running an DNS server.


func (srv *Server) ListenAndServe() error
    ListenAndServe starts a nameserver on the configured address in *Server.


type TA struct {
    Hdr        RR_Header
    KeyTag     uint16
    Algorithm  uint8
    DigestType uint8
    Digest     string `dns:"hex"`
}


func (rr *TA) Header() *RR_Header

func (rr *TA) String() string


type TALINK struct {
    Hdr          RR_Header
    PreviousName string `dns:"domain-name"`
    NextName     string `dns:"domain-name"`
}


func (rr *TALINK) Header() *RR_Header

func (rr *TALINK) String() string


type TKEY struct {
    Hdr        RR_Header
    Algorithm  string `dns:"domain-name"`
    Inception  uint32
    Expiration uint32
    Mode       uint16
    Error      uint16
    KeySize    uint16
    Key        string
    OtherLen   uint16
    OtherData  string
}


func (rr *TKEY) Header() *RR_Header

func (rr *TKEY) String() string


type TLSA struct {
    Hdr          RR_Header
    Usage        uint8
    Selector     uint8
    MatchingType uint8
    Certificate  string `dns:"hex"`
}


func (rr *TLSA) Header() *RR_Header

func (r *TLSA) Sign(usage, selector, matchingType int, cert *x509.Certificate) (err error)
    Sign creates a TLSA record from an SSL certificate.

func (rr *TLSA) String() string

func (r *TLSA) Verify(cert *x509.Certificate) error
    Verify verifies a TLSA record against an SSL certificate. If it is OK a
    nil error is returned.


type TSIG struct {
    Hdr        RR_Header
    Algorithm  string `dns:"domain-name"`
    TimeSigned uint64 `dns:"uint48"`
    Fudge      uint16
    MACSize    uint16
    MAC        string `dns:"size-hex"`
    OrigId     uint16
    Error      uint16
    OtherLen   uint16
    OtherData  string `dns:"size-hex"`
}


func (rr *TSIG) Header() *RR_Header

func (rr *TSIG) String() string


type TXT struct {
    Hdr RR_Header
    Txt []string `dns:"txt"`
}


func (rr *TXT) Header() *RR_Header

func (rr *TXT) String() string


type Token struct {
    RR                  // the scanned resource record when error is not nil
    Error   *ParseError // when an error occured, this has the error specifics
    Comment string      // A potential comment positioned after the RR and on the same line
}
    *Tokens are returned when a zone file is parsed.



type Transfer struct {
    *Conn
    DialTimeout  time.Duration     // net.DialTimeout (ns), defaults to 2 * 1e9
    ReadTimeout  time.Duration     // net.Conn.SetReadTimeout value for connections (ns), defaults to 2 * 1e9
    WriteTimeout time.Duration     // net.Conn.SetWriteTimeout value for connections (ns), defaults to 2 * 1e9
    TsigSecret   map[string]string // Secret(s) for Tsig map[<zonename>]<base64 secret>, zonename must be fully qualified
    // contains filtered or unexported fields
}
    A Transfer defines parameters that are used during a zone transfer.


func (t *Transfer) In(q *Msg, a string) (env chan *Envelope, err error)
    In performs an incoming transfer with the server in a.

func (t *Transfer) Out(w ResponseWriter, q *Msg, ch chan *Envelope) error
    Out performs an outgoing transfer with the client connecting in w. Basic
    use pattern:

	ch := make(chan *dns.Envelope)
	tr := new(dns.Transfer)
	tr.Out(w, r, ch)
	c <- &dns.Envelope{RR: []dns.RR{soa, rr1, rr2, rr3, soa}}
	close(ch)
	w.Hijack()
	// w.Close() // Client closes connection

    The server is responsible for sending the correct sequence of RRs
    through the channel ch.

func (t *Transfer) ReadMsg() (*Msg, error)
    ReadMsg reads a message from the transfer connection t.

func (t *Transfer) WriteMsg(m *Msg) (err error)
    WriteMsg writes a message through the transfer connection t.


type Type uint16


func (t Type) String() string
    String returns the string representation for the type t


type UID struct {
    Hdr RR_Header
    Uid uint32
}


func (rr *UID) Header() *RR_Header

func (rr *UID) String() string


type UINFO struct {
    Hdr   RR_Header
    Uinfo string
}


func (rr *UINFO) Header() *RR_Header

func (rr *UINFO) String() string


type URI struct {
    Hdr      RR_Header
    Priority uint16
    Weight   uint16
    Target   []string `dns:"txt"`
}


func (rr *URI) Header() *RR_Header

func (rr *URI) String() string


type WKS struct {
    Hdr      RR_Header
    Address  net.IP `dns:"a"`
    Protocol uint8
    BitMap   []uint16 `dns:"wks"`
}


func (rr *WKS) Header() *RR_Header

func (rr *WKS) String() (s string)


type X25 struct {
    Hdr         RR_Header
    PSDNAddress string
}


func (rr *X25) Header() *RR_Header

func (rr *X25) String() string



